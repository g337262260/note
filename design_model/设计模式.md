## 设计模式

1. 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

   不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例

   ```java
   //DCL方式实现单例
   public class Singleton {
           private volatile static Singleton sInstance = null;
           private Singleton() {
           }
           public void doSomething() {
             System.out.println("do sth.");
           }
           public static Singleton getInstance() {
             if (mInstance == null) {
                 synchronized (Singleton.class) {
                     if (mInstance == null) {
                         sInstance = new Singleton();
                     }
                 }
             }
             return sInstance;
         }
     //静态内部类单例模式（推荐）：确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化
     public class Singleton {
           private Singleton() { }
           public static Singleton getInstance () {
             return SingletonHolder.sInstance;
           }
           /**
           * 静态内部类：只有在被调用的时候才会被加载
           */
           private static class SingletonHolder {
               private static final Singleton sInstance = new Singleton();
           }
         }
     //使用容器实现单例模式
     public class SingletonManager {
       private static Map<String, Object> objMap = new HashMap<String,Object>();
       private SingletonManager() { }
       public static void registerService(String key, Object instance) {
           if (!objMap.containsKey(key) ) {
               objMap.put(key, instance) ;
           }
         }
         public static Object getService(String key) {
           return objMap.get(key) ;
         }
     }
   ```

   Android 中的单例模式：

   从 ContextImpl 类的部分代码中可以看到，在虚拟机第一次加载该类时会注册各种ServiceFatcher，其中就包含了 LayoutInflater Service。将这些服务以键值对的形式存储在一个HashMap中，用户使用时只需要根据key来获取到对应的ServiceFetcher，然后通过ServiceFetcher对象的 getService 函数来获取具体的服务对象。当第一次获取时，会调用 ServiceFetcher 的createService函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。
   
   单例模式的优点：
   
   1）由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。
   
   （2）由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。
   
   （3）单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。
   
   （4）单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。
   
   单例模式的缺点：
   
   （1）单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。
   
   （2）单例对象如果持有 Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context。
   
2. Builder模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

   使用场景：

   （1）相同的方法，不同的执行顺序，产生不同的事件结果时。

   （2）多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。

   （3）产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。

   （4）当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。

   Android中的Builder模式：

   AlertDialog:

   - builder：讲各个参数 赋值到 AlertController.AlertParams P

   - create: P.apply(dialog.mAlert)，将P中的参数保存到AlertDialog中

   - show：

     （1）通过dispatchOnCreate函数来调用AlertDialog的onCreate函数；

     （2）然后调用AlertDialog的onStart函数；

     （3）最后将Dialog的DecorView添加到WindowManager中。

   > WindowsManager
   >
   > 1. 各种系统服务回注册到ContextImpl的一个map容器中，包括WindowManager,然后通过该服务的字符串键来获取（WINDOW_SERVICE）
   >
   > 2. Dialog(Context context ....)
   >
   >    mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_ SERVICE)
   >
   >    在Dialog的构造函数中获取WindowManager 并与window建立联系
   >
   >    setWindowManager( )->createLocalWindowManager( )
   >
   > 3. WindowManager的addView方法请求系统将该View显示到屏幕上,添加View、移除View、更新View的布局等具体的工作都交给了WindowManagerGlobal这个类
   >
   >    addView:
   >
   >    （1）构建ViewRootImpl(继承自Handler)；
   >
   >    ​		
   >
   >    ```java
   >    保存当前线程，更新UI的线程只能是创建ViewRootImpl时的线程
   >    我们在应用开发中，如果在子线程中更新UI会抛出异常，但并不是因为只有UI线程才能更新UI
   >    而是因为ViewRootImpl是在UI线程中创建的mThread = Thread.currentThread();
   >    ```
   >
   >    （2）将布局参数设置给View；
   >
   >    （3）存储这些ViewRootImpl、View、LayoutParam到列表中；
   >
   >    （4）通过ViewRootImpl的setView将View显示到窗口上。
   >    
   >       - 请求布局：requestLayout()   向handler 中发送了一个 DO_TRAVERSAL 消息，这个消息会触发整个视图树的绘制操作，也就是最终会执行performTraversals函数
   >    
   >         ```java
   >         private void performTraversals() {
   >                 // 1.获取Surface对象，用于图形绘制
   >                 // 2.丈量整个视图树的各个View的大小，performMeasure函数
   >                 // 3.布局整个视图树，performLayout函数
   >                 // 4.绘制整棵视图树，performDraw函数
   >             }
   >         （1）判断是使用CPU绘制还是GPU绘制；
   >         （2）获取绘制表面Surface对象；
   >         （3）通过Surface对象获取并且锁住Canvas绘图对象；
   >         （4）从DecorView开始发起整棵视图树的绘制流程；
   >         （5）Surface对象解锁Canvas，并且通知SurfaceFlinger更新视图。
   >         ```
   >    
   >          -  向WMS发起请求，显示该窗口的内容
   >
   
   Builder模式在Android开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的setter方法。Builder模式比较常见的实现形式是通过调用链实现，这样使得代码更简介、易懂，例如上文说到的 ImageLoader 就是通过ImageLoaderConfig进行配置，这样避免了目标类中被过多的接口“污染”。
   
   优点
   
   （1）良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。
   
   （2）建造者独立，容易扩展。
   
   缺点
   
   会产生多余的Builder对象以及Director对象，消耗内存。
   
3. 原型模式:用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象

   使用场景:

   - 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗
   - 通过new产生一个对象需要非常繁琐的数据准备或访问权限，这时可以使用原型模式
   - 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝
   - 通过clone拷贝对象时并不会执行构造函数！因此，如果在构造函数中需要一些特殊的初始化操作的类型，在使用Cloneable实现拷贝时，需要注意构造函数不会执行的问题

   Android 中原型模式的使用：

   ```java
   Intent intent = (Intent)shareIntent.clone() ;
   //Intent中的clone方法并没有调用super.clone(),而是直接new Intent(this)
   ```

   

   

4. 

